# テスト仕様書

このドキュメントは、プロジェクトに実装されている自動テストの仕様を定義します。

## 1. ユニットテスト

ユニットテストは、個々のモジュール（クラスや関数）が期待通りに動作することを検証します。

### 1.1. ScoreManager (`tests/unit/ScoreManager.test.ts`)

**テスト対象:** `ScoreManager`クラスのスコア計算、状態管理、サーブ権判定ロジック

| テストケースID | テスト内容 | 前提条件 | 手順 | 期待される結果 |
| :--- | :--- | :--- | :--- | :--- |
| **SM-01** | **初期化** | - | 1. `ScoreManager`の新しいインスタンスを作成する。 | 1. `score1`と`score2`が`0`であること。<br>2. `isGameOver`が`false`であること。 |
| **SM-02** | **リセット** | スコア (`score1`, `score2`) とゲームオーバー状態 (`isGameOver`) が任意の値に設定されている。 | 1. `reset()`メソッドを呼び出す。 | 1. `score1`と`score2`が`0`に戻ること。<br>2. `isGameOver`が`false`に戻ること。 |
| **SM-03** | **プレイヤー1へのポイント付与** | ゲームが進行中である。 | 1. プレイヤー1（人間）がポイントを獲得する状況を示す`BallStatus`で`awardPoint()`を呼び出す。 | 1. `score1`が`1`増加すること。<br>2. `score2`は変動しないこと。 |
| **SM-04** | **プレイヤー2へのポイント付与** | ゲームが進行中である。 | 1. プレイヤー2（AI）がポイントを獲得する状況を示す`BallStatus`で`awardPoint()`を呼び出す。 | 1. `score2`が`1`増加すること。<br>2. `score1`は変動しないこと。 |
| **SM-05** | **ゲームオーバー時のポイント付与** | `isGameOver`が`true`である。 | 1. `awardPoint()`を呼び出す。 | 1. `score1`と`score2`が変動しないこと。 |
| **SM-06** | **ゲーム終了条件（通常）** | スコアが10-9（プレイヤー1リード）。 | 1. プレイヤー1がポイントを獲得する。 | 1. `isGameOver`が`true`になること。<br>2. スコアボードの表示が "You Win!" になること。 |
| **SM-07** | **ゲーム終了条件（デュース - 続行）** | スコアが10-10。 | 1. プレイヤー1がポイントを獲得する。 | 1. `isGameOver`が`false`のままであること。 |
| **SM-08** | **ゲーム終了条件（デュース - 終了）** | スコアが11-10（プレイヤー1リード）。 | 1. プレイヤー1がポイントを獲得する。 | 1. `isGameOver`が`true`になること。 |
| **SM-09** | **ゲーム終了後の画面遷移** | ゲームが終了する条件が満たされている。 | 1. `awardPoint()`を呼び出す。<br>2. `setTimeout`で設定された時間が経過する。 | 1. `returnToDemo()`メソッドが呼び出されること。 |
| **SM-10** | **サーブ権判定（11ポイント制）** | ゲームが進行中である。 | 1. 様々なスコア状況で`getService()`を呼び出す。<br>   - 0-0<br>   - 2-0<br>   - 10-10<br>   - 11-10 | 1. 各スコア状況に応じて、正しいプレイヤー (`1`または`-1`) にサーブ権が与えられること。 |

### 1.2. Ball (`tests/unit/Ball.test.ts`)

**テスト対象:** `Ball`クラスの物理演算、状態管理、衝突判定ロジック

| テストケースID | テスト内容 | 前提条件 | 手順 | 期待される結果 |
| :--- | :--- | :--- | :--- | :--- |
| **BL-01** | **初期化** | - | 1. `Ball`の新しいインスタンスを作成する。 | 1. ボールが定義された初期位置に配置されること。<br>2. 速度とスピンがゼロであること。<br>3. `status`が`BallStatus.STOP`であること。 |
| **BL-02** | **物理演算（重力と空気抵抗）** | ボールが空中にあり、上向きの初速を持つ。 | 1. `_updatePhysics()`を複数回呼び出す。 | 1. ボールのY座標が放物線を描いて変化すること。<br>2. 速度が徐々に減衰すること。 |
| **BL-03** | **テーブルとの衝突** | ボールがテーブルに向かって落下している。 | 1. `_updatePhysics()`を呼び出し、ボールがテーブルの高さに達する。 | 1. ボールのY方向の速度が反転し、反発係数に応じて減衰すること。<br>2. スピンが速度に影響を与えること。 |
| **BL-04** | **ネットとの衝突** | ボールがネットに向かって直進している。 | 1. `_updatePhysics()`を呼び出し、ボールがネットのZ座標に達する。 | 1. ボールのZ方向の速度が反転すること。 |
| **BL-05** | **壁との衝突（左右）** | ボールが左右の壁に向かって移動している。 | 1. `_updatePhysics()`を呼び出し、ボールが壁のX座標に達する。 | 1. ボールのX方向の速度が反転すること。 |
| **BL-06** | **壁との衝突（奥）** | ボールが奥の壁に向かって移動している。 | 1. `_updatePhysics()`を呼び出し、ボールが奥の壁のZ座標に達する。 | 1. ボールのZ方向の速度が反転すること。 |
| **BL-07** | **状態遷移（サーブ）** | プレイヤーがサーブの準備ができている。 | 1. `serve()`メソッドを呼び出す。 | 1. ボールの`status`が適切なサーブ状態に遷移すること。<br>2. ボールに初速とスピンが与えられること。 |

### 1.3. Player (`tests/unit/Player.test.ts`)

**テスト対象:** `Player`クラスの状態管理、サーブ、スイング、ステータスシステム

| テストケースID | テスト内容 | 前提条件 | 手順 | 期待される結果 |
| :--- | :--- | :--- | :--- | :--- |
| **PL-01** | **初期化** | - | 1. `Player`の新しいインスタンスを作成する。 | 1. `state`が`'IDLE'`であること。<br>2. `status`が`STATUS_MAX`であること。<br>3. `swing`が`0`であること。 |
| **PL-02** | **状態設定** | - | 1. `setState('IDLE')`を呼び出す。 | 1. `state`が`'IDLE'`に設定されること。<br>2. `Default`アニメーションの再生がトリガーされること。 |
| **PL-03** | **サーブタイプ変更** | スイング中でない。 | 1. `changeServeType()`を複数回呼び出す。 | 1. `swingType`がサーブの定義範囲 (`SERVE_MIN`から`SERVE_MAX`) で循環すること。 |
| **PL-04** | **サーブタイプ変更（スイング中）** | `swing`が`0`より大きい。 | 1. `changeServeType()`を呼び出す。 | 1. `swingType`が変更されないこと。 |
| **PL-05** | **サーブ可否判定（成功）** | 適切なプレイヤーサイドとボール状態 (`TOSS_P1`または`TOSS_P2`) である。 | 1. `canServe()`を呼び出す。 | 1. `true`が返されること。 |
| **PL-06** | **サーブ可否判定（失敗）** | プレイヤーサイドまたはボール状態が不適切である。 | 1. `canServe()`を呼び出す。 | 1. `false`が返されること。 |
| **PL-07** | **サーブ開始（成功）** | スイング中でない。 | 1. `startServe()`を呼び出す。 | 1. `swing`が`1`になること。<br>2. `swingType`が`SERVE_NORMAL`に設定されること。<br>3. 適切なスピンが設定されること。<br>4. サーブアニメーション (`Fcut`) が再生されること。 |
| **PL-08** | **サーブ開始（失敗）** | `swing`が`0`より大きい。 | 1. `startServe()`を呼び出す。 | 1. `false`が返され、サーブが開始されないこと。 |
| **PL-09** | **ステータス増減** | - | 1. `addStatus()`に正または負の値を渡して呼び出す。 | 1. `status`が指定された値だけ変更されること。<br>2. `status`が`1`から`STATUS_MAX`の範囲にクランプされること。 |
| **PL-10** | **ステータスリセット** | `status`が任意の値である。 | 1. `resetStatus()`を呼び出す。 | 1. `status`が`STATUS_MAX`に戻ること。 |

### 1.4. Game (`tests/unit/Game.test.ts`)

**テスト対象:** `Game`クラスの初期化、状態管理（デモ/プレイモード、一時停止）、メインループのロジック

| テストケースID | テスト内容 | 前提条件 | 手順 | 期待される結果 |
| :--- | :--- | :--- | :--- | :--- |
| **GM-01** | **初期化（デモモード）** | - | 1. `Game`の新しいインスタンスを作成する。 | 1. ゲームがデモモードで開始されること (`isDemo()`が`true`)。<br>2. プレイヤー1と2が両方ともAIとして作成されること。 |
| **GM-02** | **プレイモードへの切り替え** | ゲームがデモモードで初期化されている。 | 1. `start()`メソッドを呼び出す。 | 1. ゲームがプレイモードに切り替わること (`isDemo()`が`false`)。<br>2. プレイヤー1が人間プレイヤーとして再作成されること。 |
| **GM-03** | **一時停止と再開** | ゲームが進行中である。 | 1. `pause()`を呼び出す。<br>2. `resume()`を呼び出す。 | 1. `getIsPaused()`が`true`になること。<br>2. `getIsPaused()`が`false`に戻ること。 |
| **GM-04** | **デモモードへの復帰** | ゲームがプレイモードである。 | 1. `returnToDemo()`を呼び出す。 | 1. ゲームがデモモードに戻ること (`isDemo()`が`true`)。<br>2. プレイヤー1と2が両方ともAIとして再作成されること。 |
| **GM-05** | **メインループの更新** | ゲームが一時停止していない。 | 1. `update()`を呼び出す。 | 1. `player1`、`player2`、`ball`の`update`メソッドがそれぞれ呼び出されること。 |
| **GM-06** | **一時停止中の更新** | ゲームが一時停止している。 | 1. `update()`を呼び出す。 | 1. `player1`、`player2`、`ball`の`update`メソッドが呼び出されないこと。 |
| **GM-07** | **得点処理** | ボールがプレイ中に「デッド」状態に遷移する。 | 1. `update()`を呼び出す過程でボールの`status`が正の値から負の値に変わる。 | 1. `ScoreManager`の`awardPoint`メソッドが呼び出されること。<br>2. 両プレイヤーの`setState`が`'IDLE'`で呼び出されること。 |
| **GM-08** | **入力処理（プレイモード）** | ゲームがプレイモードである。 | 1. `update()`を呼び出す。 | 1. `InputController`の`handleInput`メソッドが呼び出されること。 |

### 1.5. CameraManager (`tests/unit/CameraManager.test.ts`)

**テスト対象:** `CameraManager`クラスのカメラ位置・注視点制御ロジック

| テストケースID | テスト内容 | 前提条件 | 手順 | 期待される結果 |
| :--- | :--- | :--- | :--- | :--- |
| **CM-01** | **初期化** | プレイヤーとボールが初期位置にある。 | 1. `update()`を呼び出す。 | 1. カメラの注視点が、テーブルの奥側に向かってスムーズに移動を開始すること。 |
| **CM-02** | **ボール追跡** | ボールがプレイヤーから見て、カメラの標準的な視野角の外に移動する。 | 1. `update()`を呼び出す。 | 1. カメラの注視点が、ボールの位置に向かってスムーズに移動を開始すること。 |
| **CM-03** | **カメラのZ位置調整** | プレイヤーがテーブルから遠ざかる。 | 1. `update()`を呼び出す。 | 1. カメラのZ位置が、プレイヤーの位置に応じて後方にオフセットされること。 |
| **CM-04** | **注視点クランプ** | ボールが地面より下に移動する。 | 1. `update()`を呼び出す。 | 1. カメラの注視点のY座標が、最低値（0.0）にクランプされること。 |

### 1.6. InputController (`tests/unit/InputController.test.ts`)

**テスト対象:** `InputController`クラスのユーザー入力（キーボード・マウス）処理ロジック

| テストケースID | テスト内容 | 前提条件 | 手順 | 期待される結果 |
| :--- | :--- | :--- | :--- | :--- |
| **IC-01** | **サーブタイプ変更** | - | 1. `inputManager`でスペースキーが押された状態をシミュレートする。<br>2. `handleInput()`を呼び出す。 | 1. `player1.changeServeType()`が呼び出されること。 |
| **IC-02** | **サーブ実行** | ボールの状態が`WAITING_FOR_SERVE`であり、サーブ権がプレイヤー1にある。 | 1. `inputManager`で左マウスクリックをシミュレートする。<br>2. `handleInput()`を呼び出す。 | 1. `player1.startServe(1)`が呼び出されること。 |
| **IC-03** | **フォワードスイング** | プレイヤーがバックスイング中 (`isInBackswing`が`true`) である。 | 1. `inputManager`で任意の（左・中・右）マウスクリックをシミュレートする。<br>2. `handleInput()`を呼び出す。 | 1. `player1.startForwardswing()`が呼び出されること。 |
| **IC-04** | **サーブ実行（サーブ権なし）** | サーブ権がプレイヤー1にない。 | 1. `inputManager`で左マウスクリックをシミュレートする。<br>2. `handleInput()`を呼び出す。 | 1. `player1.startServe()`が呼び出されないこと。 |
| **IC-05** | **ターゲット位置更新** | - | 1. `inputManager`でターゲット指定キー（例: 'w'）が押された状態をシミュレートする。<br>2. `handleInput()`を呼び出す。 | 1. `player1.targetPosition.set()`が、キーに対応する座標で呼び出されること。 |

### 1.7. InputManager (`tests/unit/InputManager.test.ts`)

**テスト対象:** `InputManager`シングルトンの低レベルな入力状態管理

| テストケースID | テスト内容 | 前提条件 | 手順 | 期待される結果 |
| :--- | :--- | :--- | :--- | :--- |
| **IM-01** | **キー押下状態の検知** | - | 1. `keydown`イベントを発行する。 | 1. `isKeyPressed()`が`true`を返すこと。 |
| **IM-02** | **キー押下（直後）の検知** | - | 1. `keydown`イベントを発行する。<br>2. `update()`を呼び出す。 | 1. 最初のフレームで`isKeyJustPressed()`が`true`を返すこと。<br>2. `update()`後の次のフレームで`isKeyJustPressed()`が`false`を返すこと。 |
| **IM-03** | **キー解放** | キーが押下されている。 | 1. `keyup`イベントを発行する。 | 1. `isKeyPressed()`が`false`を返すこと。 |
| **IM-04** | **マウスクリック状態の検知** | - | 1. `mousedown`イベントを発行する。 | 1. `isMouseButtonDown()`が`true`を返すこと。 |
| **IM-05** | **マウスクリック（直後）の検知** | - | 1. `mousedown`イベントを発行する。<br>2. `update()`を呼び出す。 | 1. 最初のフレームで`isMouseButtonJustPressed()`が`true`を返すこと。<br>2. `update()`後の次のフレームで`isMouseButtonJustPressed()`が`false`を返すこと。 |
| **IM-06** | **ポインターロック状態の更新** | - | 1. `document.pointerLockElement`をモックし、`pointerlockchange`イベントを発行する。 | 1. `isPointerLocked`プロパティが正しく更新されること。 |
| **IM-07** | **マウス移動量の追跡** | ポインターロックが有効である。 | 1. `mousemove`イベントを発行する。 | 1. `getMouseMovement()`がイベントで渡された移動量 (`movementX`, `movementY`) を返すこと。 |
| **IM-08** | **マウス移動量の追跡（ロックなし）** | ポインターロックが無効である。 | 1. `mousemove`イベントを発行する。 | 1. `getMouseMovement()`が`(0, 0)`を返すこと。 |

### 1.8. Field (`tests/unit/Field.test.ts`)

**テスト対象:** `Field`クラスの3Dオブジェクト（テーブル、壁、照明など）の構築ロジック

| テストケースID | テスト内容 | 前提条件 | 手順 | 期待される結果 |
| :--- | :--- | :--- | :--- | :--- |
| **FL-01** | **初期化** | - | 1. `Field`の新しいインスタンスを作成する。 | 1. メインとなる`THREE.Group`が作成され、`field.mesh`に割り当てられること。 |
| **FL-02** | **ターゲットインジケータの作成** | - | 1. `Field`の新しいインスタンスを作成する。 | 1. `field.targetIndicator`が`THREE.Mesh`として作成され、メイングループに追加されること。 |
| **FL-03** | **トップレベルコンポーネントの追加** | - | 1. `Field`の新しいインスタンスを作成する。 | 1. 照明、床、壁、テーブル、ネット、インジケータなど、すべての主要コンポーネントがメインの`field.mesh`に直接追加されること。 |
| **FL-04** | **照明の作成** | - | 1. `Field`の新しいインスタンスを作成する。 | 1. `DirectionalLight`と`AmbientLight`が1つずつ作成され、シーンに追加されること。 |
| **FL-05** | **床と壁の作成** | - | 1. `Field`の新しいインスタンスを作成する。 | 1. 床用に1つ、壁用に4つの`PlaneGeometry`が作成されること。 |
| **FL-06** | **テーブルコンポーネントの構築** | - | 1. `Field`の新しいインスタンスを作成する。 | 1. テーブル専用の`THREE.Group`が作成されること。<br>2. 天板、5本の線、4本の脚がすべてテーブルグループに追加されること。 |
| **FL-07** | **ネットの作成** | - | 1. `Field`の新しいインスタンスを作成する。 | 1. ネットを表す`THREE.Mesh`が作成され、メイングループに追加されること。 |

### 1.9. UIManager (`tests/unit/UIManager.test.ts`)

**テスト対象:** `UIManager`クラスの画面（デモ、一時停止、ゲーム）表示切り替えロジック

| テストケースID | テスト内容 | 前提条件 | 手順 | 期待される結果 |
| :--- | :--- | :--- | :--- | :--- |
| **UI-01** | **デモ画面の表示** | - | 1. `showDemoScreen()`を呼び出す。 | 1. `demoScreen`要素から`hidden`クラスが削除されること。<br>2. `pauseScreen`要素に`hidden`クラスが追加されること。 |
| **UI-02** | **一時停止画面の表示** | - | 1. `showPauseScreen()`を呼び出す。 | 1. `demoScreen`要素に`hidden`クラスが追加されること。<br>2. `pauseScreen`要素から`hidden`クラスが削除されること。 |
| **UI-03** | **ゲーム画面の表示** | - | 1. `showGameScreen()`を呼び出す。 | 1. `demoScreen`と`pauseScreen`の両方の要素に`hidden`クラスが追加されること。 |

### 1.10. ゲームモード (`tests/unit/modes/`)

#### 1.10.1. DemoMode (`DemoMode.test.ts`)

**テスト対象:** `DemoMode`クラスのデモシーケンス（カメラ制御、ボールリセット）ロジック

| テストケースID | テスト内容 | 前提条件 | 手順 | 期待される結果 |
| :--- | :--- | :--- | :--- | :--- |
| **DM-01** | **カメラ制御** | - | 1. `update()`を呼び出す。 | 1. カメラの位置が円を描くように更新されること。<br>2. カメラが常にテーブルの中心を向くこと (`lookAt`)。 |
| **DM-02** | **ボールリセット（デッド時）** | ボールの`status`が負の値である。 | 1. `update()`を呼び出す。 | 1. `ball.reset()`が、サーブ権を持つプレイヤーを引数として呼び出されること。 |
| **DM-03** | **ボールリセット（非デッド時）** | ボールの`status`が`0`または正の値である。 | 1. `update()`を呼び出す。 | 1. `ball.reset()`が呼び出されないこと。 |

#### 1.10.2. PlayMode (`PlayMode.test.ts`)

**テスト対象:** `PlayMode`クラスのゲームプレイ中のロジック（サーブ準備、UI更新など）

| テストケースID | テスト内容 | 前提条件 | 手順 | 期待される結果 |
| :--- | :--- | :--- | :--- | :--- |
| **PM-01** | **サーブ準備（ボールリセット）** | ボールの状態が`WAITING_FOR_SERVE`である。 | 1. `update()`を呼び出す。 | 1. `ball.reset()`が、サーブ権を持つ正しいプレイヤーを引数として呼び出されること。 |
| **PM-02** | **サーブ準備（サーブタイプ設定）** | 人間プレイヤー（`player1`）にサーブ権があり、`swingType`が無効な値である。 | 1. `update()`を呼び出す。 | 1. `player1`の`swingType`がデフォルトのサーブタイプ（`SERVE_NORMAL`）に設定されること。 |
| **PM-03** | **カメラ更新** | - | 1. `update()`を呼び出す。 | 1. `cameraManager.update()`が呼び出されること。 |
| **PM-04** | **UI更新** | - | 1. `update()`を呼び出す。 | 1. `field.targetIndicator`の位置が`player1.targetPosition`と同期されること。 |
| **PM-05** | **軌道ビジュアライザー制御** | - | 1. ボールの`justHitBySide`や`status`プロパティを様々な値に設定する。<br>2. `update()`を呼び出す。 | 1. AIが打った直後は`show()`が呼ばれること。<br>2. プレイヤーが打った直後、またはラリー終了時は`hide()`が呼ばれること。 |
| **PM-06** | **入力マネージャー更新** | - | 1. `update()`を呼び出す。 | 1. `inputManager.update()`が呼び出されること。 |

### 1.11. TrajectoryVisualizer (`tests/unit/TrajectoryVisualizer.test.ts`)

**テスト対象:** `TrajectoryVisualizer`クラスの軌道予測の視覚化ロジック

| テストケースID | テスト内容 | 前提条件 | 手順 | 期待される結果 |
| :--- | :--- | :--- | :--- | :--- |
| **TV-01** | **表示（ヒットポイントなし）** | `player.predictOptimalPlayerPosition`が`hitIndex: -1`を返す。 | 1. `show()`を呼び出す。 | 1. 軌道全体が1本の細い線(`THREE.Line`)として描画されること。<br>2. 他の視覚要素（太い線、マーカー）は作成されないこと。 |
| **TV-02** | **表示（ヒットポイントあり）** | `player.predictOptimalPlayerPosition`が有効な`hitIndex`を返す。 | 1. `show()`を呼び出す。 | 1. タイミングマーカーより前の軌道が太い線(`THREE.TubeGeometry`)で描画されること。<br>2. タイミングマーカーより後の軌道が細い線(`THREE.Line`)で描画されること。<br>3. タイミングマーカー(`THREE.SphereGeometry`)が正しい位置に表示されること。 |
| **TV-03** | **表示前のクリア処理** | - | 1. `show()`を呼び出す。 | 1. 新しい軌道を描画する前に、`hide()`メソッドが呼び出され、既存の視覚要素がクリアされること。 |
| **TV-04** | **非表示とリソース解放** | 軌道が表示されている状態。 | 1. `hide()`を呼び出す。 | 1. すべての視覚要素（線、マーカー）がシーンから削除されること。<br>2. 各要素のジオメトリとマテリアルの`dispose()`メソッドが呼び出され、リソースが解放されること。 |

### 1.12. AIController (`tests/unit/AIController.test.ts`)

**テスト対象:** `AIController`クラスの意思決定ロジック（移動、サーブ、返球）

| テストケースID | テスト内容 | 前提条件 | 手順 | 期待される結果 |
| :--- | :--- | :--- | :--- | :--- |
| **AI-01** | **初期化** | - | 1. `AIController`の新しいインスタンスを作成する。 | 1. `level`や`player`などのプロパティが正しく設定されること。 |
| **AI-02** | **移動判断（待機状態）** | ボールがサーブ待ち状態 (`WAITING_FOR_SERVE`) である。 | 1. `update()`メソッドを呼び出す。 | 1. AIプレイヤーが初期位置（またはサーブ準備位置）に移動しようとすること。 |
| **AI-03** | **移動判断（ラリー中）** | ボールがAI側に向かってきている (`RALLY_TO_AI`)。 | 1. `update()`メソッドを呼び出す。 | 1. AIプレイヤーがボールの予測落下地点に移動しようとすること。 |
| **AI-04** | **サーブ実行判断** | サーブ権がAIにあり、ボールがサーブ待ち状態である。 | 1. `update()`を複数回呼び出す。 | 1. AIプレイヤーがサーブのトスを行い、適切なタイミングでスイング（`startServe`）すること。 |
| **AI-05** | **返球実行判断** | ボールがAI側コートでバウンドし、返球可能な状態 (`RALLY_TO_AI`) である。 | 1. `update()`を複数回呼び出す。 | 1. AIプレイヤーが適切なタイミングでスイング（`startSwing`）すること。<br>**注:** このロジックはボールの未来位置予測やプレイヤーの移動など、多数の状態が複雑に絡み合うため、ユニットテストでの完全な再現が困難。現在はスキップ中。 |
| **AI-06** | **デモモードでの動作** | ゲームがデモモードである。 | 1. `update()`を呼び出す。 | 1. AIが自動的にラリーを続けること。 |

### 1.13. AssetManager (`tests/unit/AssetManager.test.ts`)

**テスト対象:** `AssetManager`クラスのアセット（モデル、テクスチャ）読み込みロジック

| テストケースID | テスト内容 | 前提条件 | 手順 | 期待される結果 |
| :--- | :--- | :--- | :--- | :--- |
| **AM-01** | **プレイヤーモデルの読み込み成功** | `GLTFLoader`がモックされ、成功時のコールバックをトリガーする。 | 1. `loadAll()`を呼び出す。 | 1. `GLTFLoader`が`player.glb`を引数として呼び出されること。<br>2. `GLTFAnimationPointerExtension`が登録されること。<br>3. `loadAll()`が返すPromiseが、モックされたGLTFオブジェクトで解決されること。 |
| **AM-02** | **プレイヤーモデルの読み込み失敗** | `GLTFLoader`がモックされ、エラー時のコールバックをトリガーする。 | 1. `loadAll()`を呼び出す。 | 1. `loadAll()`が返すPromiseが、モックされたエラーで拒否（reject）されること。 |

---

## 2. E2E（エンドツーエンド）テスト

E2Eテストは、アプリケーション全体が実際のユーザー環境（ブラウザ）で正しく動作することを検証します。

### 2.1. アプリケーション起動 (`tests/smoke.spec.ts`)

**テスト対象:** アプリケーションの起動と初期表示

| テストケースID | テスト内容 | 前提条件 | 手順 | 期待される結果 |
| :--- | :--- | :--- | :--- | :--- |
| **E2E-01** | **スモークテスト** | 開発サーバーが起動している。 | 1. アプリケーションのルートURL (`/`) にアクセスする。<br>2. ページのタイトルを検証する。<br>3. ブラウザのコンソール出力を監視する。 | 1. ページのタイトルに "CannonSmash" が含まれていること。<br>2. `error`レベルのコンソールログが出力されないこと。 |
