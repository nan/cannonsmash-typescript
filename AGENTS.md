# プロジェクトの目的

このプロジェクトの主な目的は、`cannonsmash-main`にC++で実装されている卓球ゲームをTypeScriptに移植することです。

## 主要な目標

1.  **言語の移植:** C++のコードベースを、モダンで慣用的なTypeScriptに翻訳します。
2.  **機能の同等性:** TypeScript版が、オリジナルのC++版ゲームのすべての機能を持つようにします。
3.  **保守性:** クリーンで、十分に文書化され、テスト可能なTypeScriptコードを記述します。

## 開発ガイドライン

**最重要: 移植元との差異を確認する場合**
このプロジェクトの目的はC++版の忠実な移植です。機能や定数の値について「移植元と合わせる」という指示があった場合は、**必ず以下のC++ソースコードを参照して仕様を確認してください。**
-   **オリジナルのソースコード:** [https://github.com/nan/cannonsmash](https://github.com/nan/cannonsmash)
-   **主要ファイル:** `csmash/Ball.cpp`, `csmash/Player.cpp`, `csmash/ttinc.h`

*   新しいコードはすべてTypeScriptで記述してください。
*   ロジックや機能については、オリジナルのC++実装を参照してください。
*   ユーザーとのコミュニケーションや、commit時のコメントなどは、基本的に日本語を使用してください。

### コードアーキテクチャの概要

-   **`main.ts` (コントローラー):** ユーザー入力やブラウザイベントを監視し、`Game`や`UIManager`に処理を委譲します。
-   **`Game.ts` (モデル):** ゲームのコアロジックと状態（デモ、一時停止など）を管理します。状態はカプセル化されており、外部からはメソッドを通じてのみ操作されます。
    **注:** ゲームモードを切り替える（例：デモから本番へ）際は、必ず `resetGame(isDemo: boolean)` メソッドを呼び出してください。これにより、プレイヤーの種類やスコアなどが正しく再初期化されます。
-   **`UIManager.ts` (ビュー管理):** UI要素（デモ画面、一時停止画面）の表示・非表示を管理します。

今後の開発でも、この関心の分離（SoC）の考え方を踏襲してください。

## プロジェクトの実行方法

1.  `ts-port` ディレクトリに移動します: `cd ts-port`
2.  依存関係をインストールします: `npm install`
3.  開発サーバーを起動します: `npm run dev`
4.  ブラウザで表示されたURL（通常は `http://localhost:5173` など）にアクセスします。

## ディレクトリ構成

-   `cpp_source/`: 移植元となるオリジナルのC++プロジェクトのソースコードが格納されています。(注: 現在の環境では展開に失敗する可能性があるため、上記のGitHubリンクを参照してください)
-   `ts-port/`: 移植先のTypeScriptプロジェクトです。すべての新しい開発はこのディレクトリ内で行います。

## 主要技術スタック

-   **TypeScript**: 主な開発言語です。
-   **Vite**: 開発サーバーとビルドツールとして使用します。
-   **Three.js**: 3Dグラフィックスのレンダリングに使用します。

## エージェント向けの重要な注意点

### 実行環境とツールの挙動に関する注意

-   **`run_in_bash_session`ツールのCWD:** このツールは、リポジトリのルートではなく、**`ts-port/`ディレクトリをカレントワーキングディレクトリ(CWD)としてコマンドを実行します。**
-   **その他のツールのパス:** 一方で、`read_file`や`create_file_with_block`などのツールは、リポジトリのルート (`/app`) からの絶対パスを期待します。
-   この挙動の違いを意識することで、パスに関するエラーを減らすことができます。

### コード品質とリファクタリング
`main`ブランチにマージする前には、以下のクリーンアップ作業を行ってください。
-   **console.logの扱い:** 物理演算やAIの挙動に関するデバッグログ（例: `[AI HIT]`, `[Prediction]`）は、意図的に残されています。これら以外の、一時的なデバッグ用ログは削除してください。
-   **マジックナンバーの禁止:** コード内に直接数値を記述する（マジックナンバー）のではなく、`constants.ts`に意味のある名前の定数として切り出してください。

### プレイヤーの入力制御 (Player Input Controls)

このゲームのプレイヤー（人間側）の移動は、**Pointer Lock API** を使用して制御されています。

#### 主な特徴

-   **ポインターロックの有効化:** ユーザーがゲーム画面（キャンバス）を最初にクリックすると、Pointer Lock が有効になります。これにより、OSのカーソルが非表示になり、マウスの動きがゲーム画面に直接関連付けられます。
-   **相対的なマウス移動:** プレイヤーの移動は、マウスカーソルの絶対座標（画面上のX,Yの位置）ではなく、マウスの相対的な移動量（`movementX`, `movementY`）に基づいています。これにより、画面の端を気にすることなく、直感的な操作が可能になっています。
-   **操作感度の調整:** プレイヤーの移動感度は、`ts-port/src/constants.ts` 内の `PLAYER_MOVE_SENSITIVITY_X` および `PLAYER_MOVE_SENSITIVITY_Z` 定数を変更することで調整できます。

#### 関連ファイル

-   **`ts-port/src/InputManager.ts`**: Pointer Lock の状態管理と、マウスの移動量（delta）の取得を担当します。
-   **`ts-port/src/Player.ts`**: `InputManager` から受け取った移動量に基づき、プレイヤーのメッシュを実際に動かすロジックが含まれています。
-   **`ts-port/src/main.ts`**: ゲーム開始時に、キャンバスへのクリックイベントを監視し、`requestPointerLock()` を呼び出す処理が記述されています。

### `stype` マップの解説
`ts-port/src/constants.ts` にある `stype` マップは、各スイングとサーブの動作タイミングを定義しています。各値の意味は以下の通りです。
-   `type`: スイング/サーブの種類を示すID。
-   `toss`: モーション開始からボールをトスするまでのフレーム数。サーブ以外では`-1`。
-   `backswing`: バックスイングが終了するフレーム。
-   `hitStart`: ボールをヒットする最初のフレーム。
-   `hitEnd`: ボールをヒットする最後のフレーム。
-   `swingEnd`: フォロースルーが終了するフレーム。
-   `swingLength`: アニメーション全体の長さ（フレーム数）。
-   `hitX`, `hitY`: サーブ準備時にボールを構える位置の、プレイヤーからの相対オフセット（X, Z座標）。
-   `tossV`: トス時のボールの初速（Y軸方向の速度）。

### ボールの状態 (`status`) 管理

`Ball.ts`クラスは、ボールの状態を管理するために`status`という数値プロパティを使用しています。これはオリジナルのC++コードからの直接的な移植です。

-   `status = 8`: ボールがプレイヤーに保持され、サーブ準備が整った状態。このとき、ボールの物理演算は停止します。
-   `status >= 0`: ボールがプレイ中の状態。
-   `status < 0`: ボールが「デッド」状態（例：床に落ちた、ミスショットなど）。この状態になるとリセットまでのカウントダウンが始まります。`status`が`-100`に達すると、ボールはサーブ権を持つプレイヤーの元にリセットされます。
-   **重要:** ボールがデッド状態でも、リセットされるまでは物理演算が継続されます。これにより、ボールは床で自然にバウンドし続けることができます。

### フロントエンドの検証

このゲームはブラウザベースであるため、全ての視覚的な変更は提出前に**必ず**Playwrightを使用して検証する必要があります。

-   `frontend_verification_instructions()`ツールを使用すると、検証スクリプトの書き方の詳細な手順が得られます。
-   **テストのヒント:** 特定のゲームイベントをテストするには、ゲームキャンバスへのユーザー入力をシミュレートします。
    -   **通常サーブ:** `canvas.click(button='left', ...)`
    -   **高いトス（床のバウンドテストに有効）:** `canvas.click(button='middle', ...)`

### AIの打球計算ロジック

AIの打球ロジックは、複数のファイルにまたがって実装されています。

1.  **`AIController.ts`**: AIの全体的な戦略を担当します。AIが**どこに**ボールを打つかを決定し、`player.targetPosition`を設定します。
2.  **`Player.ts`**: `hitBall`メソッドが打球の実行を開始します。
3.  **`Ball.ts`**: ターゲットにボールを到達させるために必要な**初速**を計算する、複雑な物理演算が含まれています。

この役割分担を理解することが、AIの挙動を修正する上での鍵となります。

### 既知の相違点と注意点 (Known Discrepancies and Cautionary Notes)

このセクションでは、現在のTypeScript移植版とオリジナルのC++版との間で、意図的に、あるいは技術的な困難から生じている既知の相違点について説明します。

#### サーブの速度計算 (`Ball.ts`内の`targetToVS`関数)

-   **現状:** オリジナルのC++版に存在した、サーブの着地点を狙うための動的な初速計算ロジック（反復探索）がTypeScriptに移植されました。これにより、プレイヤーが狙った相手コートの地点にサーブの2バウンド目が着地するよう、現実的な軌道が計算されます。
-   **主要なロジック:**
    -   **軌道探索:** サーバー側コートの半面全体を探索し、最適な第1バウンド地点を見つけ出します。
    -   **軌道評価:** 計算された複数の有効な軌道の中から、非現実的な山なりの高い軌道（ロブサーブ）を避け、最も水平速度が速いものを最適解として選択します。
    -   **難易度調整:** `level`引数に基づき、サーブがネットを越えるべき高さの要求マージンが変動します。`level`が高いほど、ネットすれすれの厳しいコースを狙います。

#### 物理演算の注意点 (Physics Cautionary Notes)

-   **予測と現実の一致:** `targetToVS`関数は、サーブの軌道を「予測」するための内部シミュレーションを実行します。この予測計算で使われる物理ロジック（例：スピンによるバウンド後の挙動）と、`update`および`checkCollision`関数で実行される「実際」の物理ロジックは、常に一致している必要があります。もし両者に食い違いがあると、計算された軌道からボールがずれ、サーブが失敗する原因となります。（直近の修正で、バウンド計算の不一致は修正済みです。）
-   **ネット衝突:** `checkCollision`関数には、ネット衝突時の物理挙動が実装されています。ボールはネットに当たると速度とスピンが減衰し、その後は重力に従って自然に落下します。衝突時にボールがネットに張り付いてしまう無限ループを防ぐため、衝突位置からごく僅かなオフセット（epsilon）を加えています。

#### ラリー時の打球計算 (`Ball.ts`内の`calculateRallyHitVelocity`関数)

-   **目的:** この関数は、ラリー中にAIがターゲット地点にボールを着地させるための初速を計算します。
-   **ロジック:**
    -   **軌道探索:** 複数の異なる水平速度を試行し、それぞれについてネットを越えてターゲットに着地するために必要な垂直速度を計算します。
    -   **軌道選択:** 有効な軌道（ネットをクリアし、ターゲットに到達するもの）の中から、**最も速い（=最も直線的で低い）**軌道を最初の有効解として採用します。

#### 一時的なテストコード

-   コードベースには、デバッグやテストのために一時的に追加されたコード（例: `Game.ts`内のキーボード入力ハンドラなど）が含まれている可能性があります。機能の挙動がおかしい場合は、このような一時的なコードが影響していないか確認してください。

### AIプレイヤーのロジック (`AIController.ts`)

#### AIショットのスタイル調整

AIのラリーショットの特性は、`ts-port/src/Ball.ts`の先頭で定義されている定数を調整することで変更できます。

-   `RALLY_HIT_MAX_SPEED`: AIが試行する最速の水平速度。値を大きくすると、より攻撃的になります。
-   `RALLY_HIT_MIN_SPEED`: AIが試行する最も遅い速度。
-   `RALLY_HIT_SPEED_STEP`: 有効な打球速度を探す際のステップ間隔。値を小さくすると、より最適な軌道が見つかる可能性がありますが、計算コストは増加します。
-   `NET_CLEARANCE_MARGIN`: ボールがネットを越えるべき最低限の高さ（メートル単位）。この値を大きくすると、AIのショットはより安全になりますが、山なりで遅い軌道になります。

AIの打球スタイルを変更したい場合、まずはこれらの定数を調整することから始めるのが最適です。

AIプレイヤーの挙動は、移植元のC++版 (`ComPenAttackController.cpp`) のロジックを忠実に再現することを目指して実装されています。主な特徴は以下の通りです。

#### 1. 打球タイミングの決定 (`trySwing`)

-   **動的な未来予測:** AIは、次に使用するスイング（例：ノーマルスイング）のアニメーション長（`hitStart`フレーム）に合わせて、動的に未来予測を行います。
-   **ヒッタブルゾーン:** `hitStart`フレーム後の未来において、プレイヤーとボールの位置関係が特定の範囲（ヒッタブルゾーン）に入ると予測された場合に、スイングを開始します。
-   **微調整:** さらに、AIは1フレーム先の未来を「先読み」し、そちらの方がより打球に適した位置関係になる場合は、スイングを1フレーム待機する微調整ロジックも実装されています。

#### 2. 移動ロジック (`_updateMovement`)

-   **固定加速度モデル:** AIの移動は、滑らかなダンピング（減衰）ではなく、C++版と同様の固定加速度モデルを採用しています。これにより、キビキビとした応答性の高い動きを実現しています。
-   **動的な速度制限:** 振動（小刻みな左右移動）を防ぐため、AIの最大速度は状況に応じて変化します。
    -   **ラリー中:** 高速 (5.0) で移動し、ボールに素早く追いつきます。
    -   **位置調整中（サーブ待機など）:** 低速 (1.0) で移動し、目標地点での行き過ぎ（オーバーシュート）を防ぎます。
-   **カスタムブレーキ:** 位置調整中には、C++版のカスタムブレーキ計算式 (`v*|v*a|/2 < d`) を用いて、目標地点に近づくにつれて能動的に減速するロジックが実装されています。

#### 3. 「プレイヤーとボールの距離」に関する注意点

-   ログに記録される打球時のAIプレイヤーとボールの位置に差があるのは、意図された挙動です。これは以下の要因に基づきます。
    -   AIは、ボールのバウンド後の最高到達点を目標に移動します。
    -   その最高点でボールを捉えるため、AIは自身の体が目標地点に到達する**前**にスイングを開始する必要があります。
    -   スイングアニメーションの最後の数フレームでは、AIはその場に「足を止め」、腕のリーチだけで打球します。
    -   この「先行したスイング開始」と「その場での打球」により、プレイヤーの体の中心とボールの位置には、腕のリーチ分に相当する距離が常に生じます。

## ゲームの見た目や操作感の調整について

### カメラ設定

カメラの主な設定値は、調整しやすいように `ts-port/src/constants.ts` ファイルにまとめてあります。カメラの視点を変更したい場合は、以下の定数を修正してください。

-   `CAMERA_FOV`: 視野角（ズームの度合い）を制御します。
-   `CAMERA_EYE_OFFSET`: プレイヤーを基準としたカメラのデフォルト位置（高さや距離）を制御します。

これらの値は、ユーザー様とのやり取りを通じて、元のゲームの見た目に近くなるよう微調整されています。

### フロントエンド変更の確認方法

このプロジェクトはViteで動作します。開発サーバーを起動するには、`ts-port` ディレクトリで `npm run dev` を実行してください。

**注意:** 現在の実行環境では、Playwrightを使った検証スクリプトの実行に、開発サーバーへの接続が失敗する(`net::ERR_CONNECTION_REFUSED`)という根深い問題が発生することがあります。
-   `package.json`の`dev`スクリプトに`--host`フラグを追加しても、この問題が解決しない場合があります。
-   この接続エラーに遭遇した場合は、環境固有の問題である可能性が高いです。コードのロジックに自信がある場合は、検証が失敗した旨をユーザーに報告し、作業を続行してください。
