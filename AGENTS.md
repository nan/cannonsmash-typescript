# プロジェクトの目的

このプロジェクトの主な目的は、`cannonsmash-main`にC++で実装されている卓球ゲームをTypeScriptに移植することです。

## 主要な目標

1.  **言語の移植:** C++のコードベースを、モダンで慣用的なTypeScriptに翻訳します。
2.  **機能の同等性:** TypeScript版が、オリジナルのC++版ゲームのすべての機能を持つようにします。
3.  **保守性:** クリーンで、十分に文書化され、テスト可能なTypeScriptコードを記述します。

## 開発ガイドライン

*   新しいコードはすべてTypeScriptで記述してください。
*   ロジックや機能については、オリジナルのC++実装を参照してください。
*   **オリジナルのソースコード:** [https://github.com/nan/cannonsmash](https://github.com/nan/cannonsmash)
    *   特に、ゲームロジックの重要なファイルは `csmash/Ball.cpp`, `csmash/Player.cpp`, `csmash/ttinc.h` です。

## プロジェクトの実行方法

1.  `ts-port` ディレクトリに移動します: `cd ts-port`
2.  依存関係をインストールします: `npm install`
3.  開発サーバーを起動します: `npm run dev`
4.  ブラウザで表示されたURL（通常は `http://localhost:5173` など）にアクセスします。

## ディレクトリ構成

-   `cpp_source/`: 移植元となるオリジナルのC++プロジェクトのソースコードが格納されています。(注: 現在の環境では展開に失敗する可能性があるため、上記のGitHubリンクを参照してください)
-   `ts-port/`: 移植先のTypeScriptプロジェクトです。すべての新しい開発はこのディレクトリ内で行います。

## 主要技術スタック

-   **TypeScript**: 主な開発言語です。
-   **Vite**: 開発サーバーとビルドツールとして使用します。
-   **Three.js**: 3Dグラフィックスのレンダリングに使用します。

## エージェント向けの重要な注意点

### ボールの状態 (`status`) 管理

`Ball.ts`クラスは、ボールの状態を管理するために`status`という数値プロパティを使用しています。これはオリジナルのC++コードからの直接的な移植です。

-   `status = 8`: ボールがプレイヤーに保持され、サーブ準備が整った状態。このとき、ボールの物理演算は停止します。
-   `status >= 0`: ボールがプレイ中の状態。
-   `status < 0`: ボールが「デッド」状態（例：床に落ちた、ミスショットなど）。この状態になるとリセットまでのカウントダウンが始まります。`status`が`-100`に達すると、ボールはサーブ権を持つプレイヤーの元にリセットされます。
-   **重要:** ボールがデッド状態でも、リセットされるまでは物理演算が継続されます。これにより、ボールは床で自然にバウンドし続けることができます。

### フロントエンドの検証

このゲームはブラウザベースであるため、全ての視覚的な変更は提出前に**必ず**Playwrightを使用して検証する必要があります。

-   `frontend_verification_instructions()`ツールを使用すると、検証スクリプトの書き方の詳細な手順が得られます。
-   **テストのヒント:** 特定のゲームイベントをテストするには、ゲームキャンバスへのユーザー入力をシミュレートします。
    -   **通常サーブ:** `canvas.click(button='left', ...)`
    -   **高いトス（床のバウンドテストに有効）:** `canvas.click(button='middle', ...)`

### 既知の相違点と注意点 (Known Discrepancies and Cautionary Notes)

このセクションでは、現在のTypeScript移植版とオリジナルのC++版との間で、意図的に、あるいは技術的な困難から生じている既知の相違点について説明します。

#### サーブの速度計算 (`Ball.ts`内の`targetToVS`関数)

-   **現状:** オリジナルのC++版に存在した、サーブの着地点を狙うための動的な初速計算ロジック（反復探索）がTypeScriptに移植されました。これにより、プレイヤーが狙った相手コートの地点にサーブの2バウンド目が着地するよう、現実的な軌道が計算されます。
-   **主要なロジック:**
    -   **軌道探索:** サーバー側コートの半面全体を探索し、最適な第1バウンド地点を見つけ出します。
    -   **軌道評価:** 計算された複数の有効な軌道の中から、非現実的な山なりの高い軌道（ロブサーブ）を避け、最も水平速度が速いものを最適解として選択します。
    -   **難易度調整:** `level`引数に基づき、サーブがネットを越えるべき高さの要求マージンが変動します。`level`が高いほど、ネットすれすれの厳しいコースを狙います。

#### 物理演算の注意点 (Physics Cautionary Notes)

-   **予測と現実の一致:** `targetToVS`関数は、サーブの軌道を「予測」するための内部シミュレーションを実行します。この予測計算で使われる物理ロジック（例：スピンによるバウンド後の挙動）と、`update`および`checkCollision`関数で実行される「実際」の物理ロジックは、常に一致している必要があります。もし両者に食い違いがあると、計算された軌道からボールがずれ、サーブが失敗する原因となります。（直近の修正で、バウンド計算の不一致は修正済みです。）
-   **ネット衝突:** `checkCollision`関数には、ネット衝突時の物理挙動が実装されています。ボールはネットに当たると速度とスピンが減衰し、その後は重力に従って自然に落下します。衝突時にボールがネットに張り付いてしまう無限ループを防ぐため、衝突位置からごく僅かなオフセット（epsilon）を加えています。

#### 一時的なテストコード

-   コードベースには、デバッグやテストのために一時的に追加されたコード（例: `Game.ts`内のキーボード入力ハンドラなど）が含まれている可能性があります。機能の挙動がおかしい場合は、このような一時的なコードが影響していないか確認してください。
