# プロジェクトの目的

このプロジェクトの主な目的は、`cannonsmash-main`にC++で実装されている卓球ゲームをTypeScriptに移植することです。

## 主要な目標

1.  **言語の移植:** C++のコードベースを、モダンで慣用的なTypeScriptに翻訳します。
2.  **機能の同等性:** TypeScript版が、オリジナルのC++版ゲームのすべての機能を持つようにします。
3.  **保守性:** クリーンで、十分に文書化され、テスト可能なTypeScriptコードを記述します。

## 開発ガイドライン

*   新しいコードはすべてTypeScriptで記述してください。
*   ロジックや機能については、オリジナルのC++実装を参照してください。
*   **オリジナルのソースコード:** [https://github.com/nan/cannonsmash](https://github.com/nan/cannonsmash)
    *   特に、ゲームロジックの重要なファイルは `csmash/Ball.cpp`, `csmash/Player.cpp`, `csmash/ttinc.h` です。

## プロジェクトの実行方法

1.  `ts-port` ディレクトリに移動します: `cd ts-port`
2.  依存関係をインストールします: `npm install`
3.  開発サーバーを起動します: `npm run dev`
4.  ブラウザで表示されたURL（通常は `http://localhost:5173` など）にアクセスします。

## ディレクトリ構成

-   `cpp_source/`: 移植元となるオリジナルのC++プロジェクトのソースコードが格納されています。(注: 現在の環境では展開に失敗する可能性があるため、上記のGitHubリンクを参照してください)
-   `ts-port/`: 移植先のTypeScriptプロジェクトです。すべての新しい開発はこのディレクトリ内で行います。

## 主要技術スタック

-   **TypeScript**: 主な開発言語です。
-   **Vite**: 開発サーバーとビルドツールとして使用します。
-   **Three.js**: 3Dグラフィックスのレンダリングに使用します。

## エージェント向けの重要な注意点

### ボールの状態 (`status`) 管理

`Ball.ts`クラスは、ボールの状態を管理するために`status`という数値プロパティを使用しています。これはオリジナルのC++コードからの直接的な移植です。

-   `status = 8`: ボールがプレイヤーに保持され、サーブ準備が整った状態。このとき、ボールの物理演算は停止します。
-   `status >= 0`: ボールがプレイ中の状態。
-   `status < 0`: ボールが「デッド」状態（例：床に落ちた、ミスショットなど）。この状態になるとリセットまでのカウントダウンが始まります。`status`が`-100`に達すると、ボールはサーブ権を持つプレイヤーの元にリセットされます。
-   **重要:** ボールがデッド状態でも、リセットされるまでは物理演算が継続されます。これにより、ボールは床で自然にバウンドし続けることができます。

### フロントエンドの検証

このゲームはブラウザベースであるため、全ての視覚的な変更は提出前に**必ず**Playwrightを使用して検証する必要があります。

-   `frontend_verification_instructions()`ツールを使用すると、検証スクリプトの書き方の詳細な手順が得られます。
-   **テストのヒント:** 特定のゲームイベントをテストするには、ゲームキャンバスへのユーザー入力をシミュレートします。
    -   **通常サーブ:** `canvas.click(button='left', ...)`
    -   **高いトス（床のバウンドテストに有効）:** `canvas.click(button='middle', ...)`

### AIの打球計算ロジック

AIの打球ロジックは、複数のファイルにまたがって実装されています。

1.  **`AIController.ts`**: AIの全体的な戦略を担当します。AIが**どこに**ボールを打つかを決定し、`player.targetPosition`を設定します。
2.  **`Player.ts`**: `hitBall`メソッドが打球の実行を開始します。
3.  **`Ball.ts`**: ターゲットにボールを到達させるために必要な**初速**を計算する、複雑な物理演算が含まれています。

この役割分担を理解することが、AIの挙動を修正する上での鍵となります。

### 既知の相違点と注意点 (Known Discrepancies and Cautionary Notes)

このセクションでは、現在のTypeScript移植版とオリジナルのC++版との間で、意図的に、あるいは技術的な困難から生じている既知の相違点について説明します。

#### サーブの速度計算 (`Ball.ts`内の`targetToVS`関数)

-   **現状:** オリジナルのC++版に存在した、サーブの着地点を狙うための動的な初速計算ロジック（反復探索）がTypeScriptに移植されました。これにより、プレイヤーが狙った相手コートの地点にサーブの2バウンド目が着地するよう、現実的な軌道が計算されます。
-   **主要なロジック:**
    -   **軌道探索:** サーバー側コートの半面全体を探索し、最適な第1バウンド地点を見つけ出します。
    -   **軌道評価:** 計算された複数の有効な軌道の中から、非現実的な山なりの高い軌道（ロブサーブ）を避け、最も水平速度が速いものを最適解として選択します。
    -   **難易度調整:** `level`引数に基づき、サーブがネットを越えるべき高さの要求マージンが変動します。`level`が高いほど、ネットすれすれの厳しいコースを狙います。

#### 物理演算の注意点 (Physics Cautionary Notes)

-   **予測と現実の一致:** `targetToVS`関数は、サーブの軌道を「予測」するための内部シミュレーションを実行します。この予測計算で使われる物理ロジック（例：スピンによるバウンド後の挙動）と、`update`および`checkCollision`関数で実行される「実際」の物理ロジックは、常に一致している必要があります。もし両者に食い違いがあると、計算された軌道からボールがずれ、サーブが失敗する原因となります。（直近の修正で、バウンド計算の不一致は修正済みです。）
-   **ネット衝突:** `checkCollision`関数には、ネット衝突時の物理挙動が実装されています。ボールはネットに当たると速度とスピンが減衰し、その後は重力に従って自然に落下します。衝突時にボールがネットに張り付いてしまう無限ループを防ぐため、衝突位置からごく僅かなオフセット（epsilon）を加えています。

#### ラリー時の打球計算 (`Ball.ts`内の`calculateRallyHitVelocity`関数)

-   **目的:** この関数は、ラリー中にAIがターゲット地点にボールを着地させるための初速を計算します。
-   **ロジック:**
    -   **軌道探索:** 複数の異なる水平速度を試行し、それぞれについてネットを越えてターゲットに着地するために必要な垂直速度を計算します。
    -   **軌道選択:** 有効な軌道（ネットをクリアし、ターゲットに到達するもの）の中から、**最も速い（=最も直線的で低い）**軌道を最初の有効解として採用します。

#### 一時的なテストコード

-   コードベースには、デバッグやテストのために一時的に追加されたコード（例: `Game.ts`内のキーボード入力ハンドラなど）が含まれている可能性があります。機能の挙動がおかしい場合は、このような一時的なコードが影響していないか確認してください。

### AIプレイヤーのロジック (`AIController.ts`)

#### AIショットのスタイル調整

AIのラリーショットの特性は、`ts-port/src/Ball.ts`の先頭で定義されている定数を調整することで変更できます。

-   `RALLY_HIT_MAX_SPEED`: AIが試行する最速の水平速度。値を大きくすると、より攻撃的になります。
-   `RALLY_HIT_MIN_SPEED`: AIが試行する最も遅い速度。
-   `RALLY_HIT_SPEED_STEP`: 有効な打球速度を探す際のステップ間隔。値を小さくすると、より最適な軌道が見つかる可能性がありますが、計算コストは増加します。
-   `NET_CLEARANCE_MARGIN`: ボールがネットを越えるべき最低限の高さ（メートル単位）。この値を大きくすると、AIのショットはより安全になりますが、山なりで遅い軌道になります。

AIの打球スタイルを変更したい場合、まずはこれらの定数を調整することから始めるのが最適です。

AIプレイヤーの挙動は、移植元のC++版 (`ComPenAttackController.cpp`) のロジックを忠実に再現することを目指して実装されています。主な特徴は以下の通りです。

#### 1. 打球タイミングの決定 (`trySwing`)

-   **動的な未来予測:** AIは、次に使用するスイング（例：ノーマルスイング）のアニメーション長（`hitStart`フレーム）に合わせて、動的に未来予測を行います。
-   **ヒッタブルゾーン:** `hitStart`フレーム後の未来において、プレイヤーとボールの位置関係が特定の範囲（ヒッタブルゾーン）に入ると予測された場合に、スイングを開始します。
-   **微調整:** さらに、AIは1フレーム先の未来を「先読み」し、そちらの方がより打球に適した位置関係になる場合は、スイングを1フレーム待機する微調整ロジックも実装されています。

#### 2. 移動ロジック (`_updateMovement`)

-   **固定加速度モデル:** AIの移動は、滑らかなダンピング（減衰）ではなく、C++版と同様の固定加速度モデルを採用しています。これにより、キビキビとした応答性の高い動きを実現しています。
-   **動的な速度制限:** 振動（小刻みな左右移動）を防ぐため、AIの最大速度は状況に応じて変化します。
    -   **ラリー中:** 高速 (5.0) で移動し、ボールに素早く追いつきます。
    -   **位置調整中（サーブ待機など）:** 低速 (1.0) で移動し、目標地点での行き過ぎ（オーバーシュート）を防ぎます。
-   **カスタムブレーキ:** 位置調整中には、C++版のカスタムブレーキ計算式 (`v*|v*a|/2 < d`) を用いて、目標地点に近づくにつれて能動的に減速するロジックが実装されています。

#### 3. 「プレイヤーとボールの距離」に関する注意点

-   ログに記録される打球時のAIプレイヤーとボールの位置に差があるのは、意図された挙動です。これは以下の要因に基づきます。
    -   AIは、ボールのバウンド後の最高到達点を目標に移動します。
    -   その最高点でボールを捉えるため、AIは自身の体が目標地点に到達する**前**にスイングを開始する必要があります。
    -   スイングアニメーションの最後の数フレームでは、AIはその場に「足を止め」、腕のリーチだけで打球します。
    -   この「先行したスイング開始」と「その場での打球」により、プレイヤーの体の中心とボールの位置には、腕のリーチ分に相当する距離が常に生じます。

## ゲームの見た目や操作感の調整について

### カメラ設定

カメラの主な設定値は、調整しやすいように `ts-port/src/constants.ts` ファイルにまとめてあります。カメラの視点を変更したい場合は、以下の定数を修正してください。

-   `CAMERA_FOV`: 視野角（ズームの度合い）を制御します。
-   `CAMERA_EYE_OFFSET`: プレイヤーを基準としたカメラのデフォルト位置（高さや距離）を制御します。

これらの値は、ユーザー様とのやり取りを通じて、元のゲームの見た目に近くなるよう微調整されています。

### フロントエンド変更の確認方法

このプロジェクトはViteで動作します。開発サーバーを起動するには、`ts-port` ディレクトリで `npm run dev` を実行してください。

**注意:** 現在の実行環境では、Playwrightを使った検証スクリプトの実行に問題が発生することがあります。
-   検証スクリプトは `ts-port` のルートディレクトリに作成し、そこから実行することを推奨します。
-   また、スクリプトが生成したスクリーンショットをツールで読み取れない場合があります。その際は、変更内容をユーザー様に説明し、確認を依頼してください。
