# プロジェクトの目的

> **Note:** このプロジェクトの3D空間では、手前側が**人間プレイヤー(Player 1)で+Z座標**、奥側が**AIプレイヤー(Player 2)で-Z座標**となっています。

このプロジェクトの主な目的は、`cannonsmash-main`にC++で実装されている卓球ゲームをTypeScriptに移植することです。

## 主要な目標

1.  **言語の移植:** C++のコードベースを、モダンで慣用的なTypeScriptに翻訳します。
2.  **機能の同等性:** TypeScript版が、オリジナルのC++版ゲームのすべての機能を持つようにします。
3.  **保守性:** クリーンで、十分に文書化され、テスト可能なTypeScriptコードを記述します。

## 開発ガイドライン

**最重要: 移植元との差異を確認する場合**
このプロジェクトの目的はC++版の忠実な移植です。機能や定数の値について「移植元と合わせる」という指示があった場合は、**必ず以下のC++ソースコードを参照して仕様を確認してください。**
-   **オリジナルのソースコード:** [https://github.com/nan/cannonsmash](https://github.com/nan/cannonsmash)
-   **主要ファイル:** `csmash/Ball.cpp`, `csmash/Player.cpp`, `csmash/ttinc.h`

*   新しいコードはすべてTypeScriptで記述してください。
*   ロジックや機能については、オリジナルのC++実装を参照してください。
*   ユーザーとのコミュニケーションや、commit時のコメントなどは、基本的に日本語を使用してください。

### コードアーキテクチャの概要

-   **`main.ts` (コントローラー):** ユーザー入力やブラウザイベントを監視し、`Game`や`UIManager`に処理を委譲します。
-   **`Game.ts` (モデル):** ゲームのコアロジックと状態（デモ、一時停止など）を管理します。状態はカプセル化されており、外部からはメソッドを通じてのみ操作されます。
    **注:** ゲームモードを切り替える（例：デモから本番へ）際は、必ず `resetGame(isDemo: boolean)` メソッドを呼び出してください。これにより、プレイヤーの種類やスコアなどが正しく再初期化されます。
-   **`UIManager.ts` (ビュー管理):** UI要素（デモ画面、一時停止画面）の表示・非表示を管理します。

今後の開発でも、この関心の分離（SoC）の考え方を踏襲してください。

## プロジェクトの実行方法

1.  `ts-port` ディレクトリに移動します: `cd ts-port`
2.  依存関係をインストールします: `npm install`
3.  開発サーバーを起動します: `npm run dev`
4.  ブラウザで表示されたURL（通常は `http://localhost:5173` など）にアクセスします。

## ディレクトリ構成

-   `cpp_source/`: 移植元となるオリジナルのC++プロジェクトのソースコードが格納されています。(注: 現在の環境では展開に失敗する可能性があるため、上記のGitHubリンクを参照してください)
-   `ts-port/`: 移植先のTypeScriptプロジェクトです。すべての新しい開発はこのディレクトリ内で行います。

## 主要技術スタック

-   **TypeScript**: 主な開発言語です。
-   **Vite**: 開発サーバーとビルドツールとして使用します。
-   **Three.js**: 3Dグラフィックスのレンダリングに使用します。

## エージェント向けの重要な注意点

### 実行環境とツールの挙動に関する注意

-   **`run_in_bash_session`ツールのCWD:** このツールは、リポジトリのルートではなく、**`ts-port/`ディレクトリをカレントワーキングディレクトリ(CWD)としてコマンドを実行します。**
-   **その他のツールのパス:** 一方で、`read_file`や`create_file_with_block`などのツールは、リポジトリのルート (`/app`) からの絶対パスを期待します。
-   この挙動の違いを意識することで、パスに関するエラーを減らすことができます。

### コード品質とリファクタリング
`main`ブランチにマージする前には、以下のクリーンアップ作業を行ってください。
-   **console.logの扱い:** 物理演算やAIの挙動に関するデバッグログ（例: `[AI HIT]`, `[Prediction]`）は、意図的に残されています。これら以外の、一時的なデバッグ用ログは削除してください。
-   **マジックナンバーの禁止:** コード内に直接数値を記述する（マジックナンバー）のではなく、`constants.ts`に意味のある名前の定数として切り出してください。

### プレイヤーの入力制御 (Player Input Controls)

このゲームのプレイヤー（人間側）の移動は、**Pointer Lock API** を使用して制御されています。

#### 主な特徴

-   **ポインターロックの有効化:** ユーザーがゲーム画面（キャンバス）を最初にクリックすると、Pointer Lock が有効になります。これにより、OSのカーソルが非表示になり、マウスの動きがゲーム画面に直接関連付けられます。
-   **相対的なマウス移動:** プレイヤーの移動は、マウスカーソルの絶対座標（画面上のX,Yの位置）ではなく、マウスの相対的な移動量（`movementX`, `movementY`）に基づいています。これにより、画面の端を気にすることなく、直感的な操作が可能になっています。
-   **操作感度の調整:** プレイヤーの移動感度は、`ts-port/src/constants.ts` 内の `PLAYER_MOVE_SENSITIVITY_X` および `PLAYER_MOVE_SENSITIVITY_Z` 定数を変更することで調整できます。

#### 関連ファイル

-   **`ts-port/src/InputManager.ts`**: Pointer Lock の状態管理と、マウスの移動量（delta）の取得を担当します。
-   **`ts-port/src/Player.ts`**: `InputManager` から受け取った移動量に基づき、プレイヤーのメッシュを実際に動かすロジックが含まれています。
-   **`ts-port/src/main.ts`**: ゲーム開始時に、キャンバスへのクリックイベントを監視し、`requestPointerLock()` を呼び出す処理が記述されています。

### `stype` マップの解説
`ts-port/src/constants.ts` にある `stype` マップは、各スイングとサーブの動作タイミングを定義しています。各値の意味は以下の通りです。
-   `type`: スイング/サーブの種類を示すID。
-   `toss`: モーション開始からボールをトスするまでのフレーム数。サーブ以外では`-1`。
-   `backswing`: バックスイングが終了するフレーム。
-   `hitStart`: ボールをヒットする最初のフレーム。
-   `hitEnd`: ボールをヒットする最後のフレーム。
-   `swingEnd`: フォロースルーが終了するフレーム。
-   `swingLength`: アニメーション全体の長さ（フレーム数）。
-   `hitX`, `hitY`: サーブ準備時にボールを構える位置の、プレイヤーからの相対オフセット（X, Z座標）。
-   `tossV`: トス時のボールの初速（Y軸方向の速度）。

### ボールの状態 (`status`) 管理

`Ball.ts`クラスは、ボールの状態を管理するために`status`という数値プロパティを使用しています。これはオリジナルのC++コードからの直接的な移植です。

-   `status = 8`: ボールがプレイヤーに保持され、サーブ準備が整った状態。このとき、ボールの物理演算は停止します。
-   `status >= 0`: ボールがプレイ中の状態。
-   `status < 0`: ボールが「デッド」状態（例：床に落ちた、ミスショットなど）。この状態になるとリセットまでのカウントダウンが始まります。`status`が`-100`に達すると、ボールはサーブ権を持つプレイヤーの元にリセットされます。
-   **重要:** ボールがデッド状態でも、リセットされるまでは物理演算が継続されます。これにより、ボールは床で自然にバウンドし続けることができます。

### フロントエンドの検証

このゲームはブラウザベースであるため、全ての視覚的な変更は提出前に**必ず**Playwrightを使用して検証する必要があります。

-   `frontend_verification_instructions()`ツールを使用すると、検証スクリプトの書き方の詳細な手順が得られます。
-   **テストのヒント:** 特定のゲームイベントをテストするには、ゲームキャンバスへのユーザー入力をシミュレートします。
    -   **通常サーブ:** `canvas.click(button='left', ...)`
    -   **高いトス（床のバウンドテストに有効）:** `canvas.click(button='middle', ...)`

### AIの打球計算ロジック

AIの打球ロジックは、複数のファイルにまたがって実装されています。

1.  **`AIController.ts`**: AIの全体的な戦略を担当します。AIが**どこに**ボールを打つかを決定し、`player.targetPosition`を設定します。
2.  **`Player.ts`**: `hitBall`メソッドが打球の実行を開始します。
3.  **`Ball.ts`**: ターゲットにボールを到達させるために必要な**初速**を計算する、複雑な物理演算が含まれています。

この役割分担を理解することが、AIの挙動を修正する上での鍵となります。

### 既知の相違点と注意点 (Known Discrepancies and Cautionary Notes)

このセクションでは、現在のTypeScript移植版とオリジナルのC++版との間で、意図的に、あるいは技術的な困難から生じている既知の相違点について説明します。

#### サーブの速度計算 (`Ball.ts`内の`targetToVS`関数)

-   **現状:** オリジナルのC++版に存在した、サーブの着地点を狙うための動的な初速計算ロジック（反復探索）がTypeScriptに移植されました。これにより、プレイヤーが狙った相手コートの地点にサーブの2バウンド目が着地するよう、現実的な軌道が計算されます。
-   **主要なロジック:**
    -   **軌道探索:** サーバー側コートの半面全体を探索し、最適な第1バウンド地点を見つけ出します。
    -   **軌道評価:** 計算された複数の有効な軌道の中から、非現実的な山なりの高い軌道（ロブサーブ）を避け、最も水平速度が速いものを最適解として選択します。
    -   **難易度調整:** `level`引数に基づき、サーブがネットを越えるべき高さの要求マージンが変動します。`level`が高いほど、ネットすれすれの厳しいコースを狙います。

#### 物理演算の注意点 (Physics Cautionary Notes)

-   **予測と現実の一致:** `targetToVS`関数は、サーブの軌道を「予測」するための内部シミュレーションを実行します。この予測計算で使われる物理ロジック（例：スピンによるバウンド後の挙動）と、`update`および`checkCollision`関数で実行される「実際」の物理ロジックは、常に一致している必要があります。もし両者に食い違いがあると、計算された軌道からボールがずれ、サーブが失敗する原因となります。（直近の修正で、バウンド計算の不一致は修正済みです。）
-   **ネット衝突:** `checkCollision`関数には、ネット衝突時の物理挙動が実装されています。ボールはネットに当たると速度とスピンが減衰し、その後は重力に従って自然に落下します。衝突時にボールがネットに張り付いてしまう無限ループを防ぐため、衝突位置からごく僅かなオフセット（epsilon）を加えています。

#### ラリー時の打球計算 (`Ball.ts`内の`calculateRallyHitVelocity`関数)

-   **目的:** この関数は、ラリー中にAIがターゲット地点にボールを着地させるための初速を計算します。
-   **ロジック:**
    -   **軌道探索:** 複数の異なる水平速度を試行し、それぞれについてネットを越えてターゲットに着地するために必要な垂直速度を計算します。
    -   **軌道選択:** 有効な軌道（ネットをクリアし、ターゲットに到達するもの）の中から、**最も速い（=最も直線的で低い）**軌道を最初の有効解として採用します。

#### 一時的なテストコード

-   コードベースには、デバッグやテストのために一時的に追加されたコード（例: `Game.ts`内のキーボード入力ハンドラなど）が含まれている可能性があります。機能の挙動がおかしい場合は、このような一時的なコードが影響していないか確認してください。

### AIプレイヤーのロジック (`AIController.ts`)

#### AIショットのスタイル調整

AIのラリーショットの特性は、`ts-port/src/Ball.ts`の先頭で定義されている定数を調整することで変更できます。

-   `RALLY_HIT_MAX_SPEED`: AIが試行する最速の水平速度。値を大きくすると、より攻撃的になります。
-   `RALLY_HIT_MIN_SPEED`: AIが試行する最も遅い速度。
-   `RALLY_HIT_SPEED_STEP`: 有効な打球速度を探す際のステップ間隔。値を小さくすると、より最適な軌道が見つかる可能性がありますが、計算コストは増加します。
-   `NET_CLEARANCE_MARGIN`: ボールがネットを越えるべき最低限の高さ（メートル単位）。この値を大きくすると、AIのショットはより安全になりますが、山なりで遅い軌道になります。

AIの打球スタイルを変更したい場合、まずはこれらの定数を調整することから始めるのが最適です。

AIプレイヤーの挙動は、移植元のC++版 (`ComPenAttackController.cpp`) のロジックを忠実に再現することを目指して実装されています。主な特徴は以下の通りです。

#### 1. 打球タイミングの決定 (`trySwing`)

-   **動的な未来予測:** AIは、次に使用するスイング（例：ノーマルスイング）のアニメーション長（`hitStart`フレーム）に合わせて、動的に未来予測を行います。
-   **ヒッタブルゾーン:** `hitStart`フレーム後の未来において、プレイヤーとボールの位置関係が特定の範囲（ヒッタブルゾーン）に入ると予測された場合に、スイングを開始します。
-   **微調整:** さらに、AIは1フレーム先の未来を「先読み」し、そちらの方がより打球に適した位置関係になる場合は、スイングを1フレーム待機する微調整ロジックも実装されています。

#### 2. 移動ロジック (`_updateMovement`)

-   **固定加速度モデル:** AIの移動は、滑らかなダンピング（減衰）ではなく、C++版と同様の固定加速度モデルを採用しています。これにより、キビキビとした応答性の高い動きを実現しています。
-   **動的な速度制限:** 振動（小刻みな左右移動）を防ぐため、AIの最大速度は状況に応じて変化します。
    -   **ラリー中:** 高速 (5.0) で移動し、ボールに素早く追いつきます。
    -   **位置調整中（サーブ待機など）:** 低速 (1.0) で移動し、目標地点での行き過ぎ（オーバーシュート）を防ぎます。
-   **カスタムブレーキ:** 位置調整中には、C++版のカスタムブレーキ計算式 (`v*|v*a|/2 < d`) を用いて、目標地点に近づくにつれて能動的に減速するロジックが実装されています。

#### 3. 「プレイヤーとボールの距離」に関する注意点

-   ログに記録される打球時のAIプレイヤーとボールの位置に差があるのは、意図された挙動です。これは以下の要因に基づきます。
    -   AIは、ボールのバウンド後の最高到達点を目標に移動します。
    -   その最高点でボールを捉えるため、AIは自身の体が目標地点に到達する**前**にスイングを開始する必要があります。
    -   スイングアニメーションの最後の数フレームでは、AIはその場に「足を止め」、腕のリーチだけで打球します。
    -   この「先行したスイング開始」と「その場での打球」により、プレイヤーの体の中心とボールの位置には、腕のリーチ分に相当する距離が常に生じます。

#### 4. サーブロジック (`update`メソッド内)

AIがサーブを実行する際のロジックは、以下のステップで構成されています。このシーケンスを正しく実装することが重要です。

1.  **目標地点の設定:** AIのサーブターンになった場合、**毎フレーム**、AIの移動目標地点（`predictedHitPosition`）を、サーブ用の「ホームポジション」に設定し続ける必要があります。これにより、AIは常に正しい場所へ移動しようとします。（注: この目標設定を怠ると、AIはラリー終了時の古い目標地点に向かおうとし、サーブ位置に到達できなくなります。）

2.  **移動と待機:** `_updateMovement`ロジックが、ステップ1で設定されたホームポジションへAIを移動させます。

3.  **状態確認:** AIがサーブを開始する直前に、以下の2つの条件が満たされているかを確認します。
    *   **安定しているか (`isStable`):** AIのX軸とZ軸、それぞれの速度が特定のしきい値（例: 0.2）未満であること。ベクトル全体の大きさではなく、各成分で評価するのが元の実装です。
    *   **正しい位置にいるか (`isAtPosition`):** AIの体の中心が、目標地点（ホームポジション）からラケットのオフセット分だけずれた「理想的なサーブ位置」の、特定の許容誤差（例: 0.1）以内にいること。

4.  **サーブ実行:** 上記の条件がすべて満たされた場合にのみ、`player.startServe()`を呼び出してサーブを実行します。

## ゲームの見た目や操作感の調整について

### カメラ設定

カメラの主な設定値は、調整しやすいように `ts-port/src/constants.ts` ファイルにまとめてあります。カメラの視点を変更したい場合は、以下の定数を修正してください。

-   `CAMERA_FOV`: 視野角（ズームの度合い）を制御します。
-   `CAMERA_EYE_OFFSET`: プレイヤーを基準としたカメラのデフォルト位置（高さや距離）を制御します。

これらの値は、ユーザー様とのやり取りを通じて、元のゲームの見た目に近くなるよう微調整されています。

### フロントエンド変更の確認方法

このプロジェクトはViteで動作します。開発サーバーを起動するには、`ts-port` ディレクトリで `npm run dev` を実行してください。

**注意:** 現在の実行環境は、Playwrightから開発サーバーへの接続が失敗する(`net::ERR_CONNECTION_REFUSED`)という根深い問題を抱えています。このため、**`npm run dev`の実行はほぼ確実に失敗し、Playwrightによる画面の視覚的な検証は事実上不可能です。** コードのロジックに自信がある場合は、この検証ステップをスキップし、その旨をユーザーに報告して作業を続行してください。

> **検証スクリプトの実行に関する注意 (Note on Executing Verification Scripts):**
> 現在のサンドボックス環境では、`create_file_with_block`で検証用スクリプトファイルを作成した直後に、そのファイルを実行しようとすると「ファイルが見つからない (No such file or directory)」というエラーで失敗することがあります。これは、ファイルシステムの同期に遅延がある可能性を示唆する、環境の不安定性に起因する問題です。
>
> この問題に遭遇した場合、何度か再試行しても解決しない可能性が高いです。その際は、長々とデバッグに時間を費やすのではなく、ユーザーに状況を報告してください。多くの場合、ユーザー自身が手元で検証を行うため、コードをそのままコミットするよう指示があります。

### 主要な概念とロジック

### ボールの状態遷移（ステートマシン）

このゲームの核心的なロジックは、`Ball.ts`内の`status`プロパティによって管理される状態遷移にあります。AIの行動判断や得点計算はすべてこの`status`に依存しているため、このフローの理解は非常に重要です。

#### サーブ時のフロー (人間プレイヤーがサーブする場合)

1.  `TOSS_P1`: プレイヤーがボールをトスした状態。
2.  `SERVE_TO_AI`: ラケットがボールに当たり、AI側に向かっている状態。
3.  `IN_PLAY_TO_AI`: ボールが自コート（+Z側）で1バウンドした状態。サーブが正規のものであることを示す。
4.  `RALLY_TO_AI`: ボールがAIコート（-Z側）で2バウンドした状態。この状態になったボールをAIは打ち返すことができる。

#### ラリー時のフロー (人間プレイヤーが打ち返した場合)

1.  `RALLY_TO_HUMAN`: AIの打球が自コートでバウンドし、人間が打ち返せる状態。
2.  `IN_PLAY_TO_AI`: 人間が打ち返した直後で、AIコートに向かっている状態。
3.  `RALLY_TO_AI`: AIコートでバウンドし、AIが打ち返せる状態になった。

#### ボールの状態 (`ball.status`)
ボールの状態は `Ball.ts` 内の `status` プロパティで管理されています。ラリー中の主な状態遷移は以下の通りです。
- `2`: 相手が打ち、自コートに向かってきている状態（バウンド前）
- `3`: 自コートでバウンドした状態
- `0`: 自分が打ち返した状態
- `1`: 相手コートでバウンドした状態

#### プレイヤーの「移動目標地点」と「打球タイミングマーカー」
この2つは異なる概念であり、異なるロジックで計算されます。
- **移動目標地点:** プレイヤーがボールを打つのに最適な**立ち位置**を示します。これは `Player.ts` の `predictOptimalPlayerPosition` で計算され、主にバウンド後の軌道の頂点が目標となります。
- **打球タイミングマーカー:** プレイヤーがマウスをクリックすべき**タイミング**を示すためのものです。これは `TrajectoryVisualizer.ts` で計算され、最適な打点からスイングのタイムラグを遡った位置に表示されます。

#### タイミングマーカーの計算式
打球タイミングマーカーの計算で用いるタイムラグ（フレーム数）は、スイングの「フォワードスイング」にかかる時間です。これは以下の式で計算されます。
`タイムラグ = swingParams.hitStart - swingParams.backswing`

### AIの挙動と難易度調整について

このプロジェクトのAIプレイヤーの難易度は、`Player`クラスに実装されている**ステータスシステム**によって制御されています。これは、AIの「疲労」や「集中力」をシミュレートするための仕組みです。

**主要なファイル:**

*   `ts-port/src/Player.ts`: AIのステータス(`status`)の管理と、それに基づいたエラー（ミス）を追加する`addError`メソッドなど、中核となるロジックが含まれています。
*   `ts-port/src/Game.ts`: ポイント終了時にプレイヤーのステータスをリセットするなど、ゲーム全体の状態を管理しています。
*   `ts-port/src/constants.ts`: AIの難易度に直接影響するパラメータ（定数）が定義されています。

**AIの難易度を調整する方法:**

AIの強さやミスのしやすさを調整したい場合は、主に`ts-port/src/constants.ts`内の以下の定数を変更してください。

*   `STATUS_MAX`: ステータスの最大値。これを下げるほど、AIは早く疲れるようになります。
*   `RUN_PENALTY`, `SWING_PENALTY`, `ACCEL_PENALTY`: AIが行動した際のステータス減少量です。これらの値の絶対値を大きくすると、AIはより早く疲れます。
*   `WALK_BONUS`: AIが静止している際のステータス回復量です。
*   `ACCEL_LIMIT`: AIがペナルティを受けずに許容される最大の加速度です。この値を小さくすると、AIは少しの急加速でもペナルティを受けるようになり、動きが慎重になります。

`addError`メソッド内の計算式（特に`radDiff`に乗算している係数）を変更することでも、ミスの度合いを調整できます。

---
*ここから追記*

## ゲームの基本構造

このプロジェクトは、TypeScriptで書かれた3D卓球ゲームです。主要なロジックは以下のファイルに分かれています。

-   `src/Game.ts`: メインのゲームループ、スコア管理、人間プレイヤーの入力処理を担当します。
-   `src/Player.ts`: プレイヤー（人間・AI共通）の状態や、スイング、移動などのアクションを定義します。
-   `src/Ball.ts`: ボールの物理演算、状態遷移、衝突判定を管理します。
-   `src/AIController.ts`: AIプレイヤーの思考ロジック（打点予測、移動、スイング判断）を専門に扱います。
-   `src/constants.ts`: ゲーム内で使用される物理パラメータや設定値が定義されています。

## 重要な設計概念

### スイングの準備と実行の分離

プレイヤーのアクションを制御する上で、スイングの「準備開始」と「実際のヒット」は区別されています。

-   **`player.canInitiateSwing()`**: スイングアニメーションを開始できるかどうかを判断します。相手がボールを打った直後（ボールが自コートに向かって飛んでいる最中）から `true` を返します。これにより、プレイヤーはボールのバウンドを待たずに、予測してスイングを始めることができます。
-   **`player.canHitBall()`**: スイングアニメーションの途中で、ボールに実際にインパクト（ヒット）させることがルール上可能かどうかを判断します。こちらは、ボールが自コートでバウンドした後にのみ `true` を返します。

機能修正やリファクタリングの際は、この2つのメソッドの役割の違いを理解することが重要です。

## 開発・修正の進め方

-   **リファクタリングの推奨**: 機能追加や修正が完了した後、`main`ブランチにマージする前に、コードの可読性や保守性を向上させるためのリファクタリングが推奨されます。ロジックの重複を排除し、関連する処理をメソッドにまとめるなど、積極的に提案してください。
-   **テスト**: このプロジェクトには自動テストがセットアップされていません。変更を加えた際は、関連するファイルを注意深く読み返し、論理的に問題がないことを十分に確認してください。
